$date
	Wed Sep 11 09:28:00 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module reg_writer_test $end
$var wire 5 ! regnum [4:0] $end
$var wire 1 " done $end
$var reg 1 # clock $end
$var reg 32 $ data [31:0] $end
$var reg 1 % direction $end
$var reg 1 & go $end
$var reg 1 ' reset $end
$scope module rf $end
$var wire 1 # clock $end
$var wire 32 ( internal_rdData [31:0] $end
$var wire 32 ) rdData [31:0] $end
$var wire 1 * rdWriteEnable $end
$var wire 1 ' reset $end
$var wire 32 + rsData [31:0] $end
$var wire 5 , rsNum [4:0] $end
$var wire 32 - rtData [31:0] $end
$var wire 5 . rtNum [4:0] $end
$var wire 5 / rdNum [4:0] $end
$var integer 32 0 i [31:0] $end
$upscope $end
$scope module writer $end
$var wire 1 # clock $end
$var wire 1 % direction $end
$var wire 1 " done $end
$var wire 1 & go $end
$var wire 1 ' reset $end
$var wire 1 1 sDone_next $end
$var wire 1 2 sDown1_next $end
$var wire 1 3 sDown2_next $end
$var wire 1 4 sDown3_next $end
$var wire 1 5 sDown4_next $end
$var wire 1 6 sGarbage_next $end
$var wire 1 7 sStart_next $end
$var wire 1 8 sUp1_next $end
$var wire 1 9 sUp2_next $end
$var wire 1 : sUp3_next $end
$var wire 1 ; sUp4_next $end
$var wire 1 < sUp4 $end
$var wire 1 = sUp3 $end
$var wire 1 > sUp2 $end
$var wire 1 ? sUp1 $end
$var wire 1 @ sStart $end
$var wire 1 A sGarbage $end
$var wire 1 B sDown4 $end
$var wire 1 C sDown3 $end
$var wire 1 D sDown2 $end
$var wire 1 E sDown1 $end
$var wire 1 F sDone $end
$var wire 5 G regnum [4:0] $end
$scope module fsDone $end
$var wire 1 # clk $end
$var wire 1 1 d $end
$var wire 1 H enable $end
$var wire 1 I reset $end
$var reg 1 F q $end
$upscope $end
$scope module fsDown1 $end
$var wire 1 # clk $end
$var wire 1 2 d $end
$var wire 1 J enable $end
$var wire 1 K reset $end
$var reg 1 E q $end
$upscope $end
$scope module fsDown2 $end
$var wire 1 # clk $end
$var wire 1 3 d $end
$var wire 1 L enable $end
$var wire 1 M reset $end
$var reg 1 D q $end
$upscope $end
$scope module fsDown3 $end
$var wire 1 # clk $end
$var wire 1 4 d $end
$var wire 1 N enable $end
$var wire 1 O reset $end
$var reg 1 C q $end
$upscope $end
$scope module fsDown4 $end
$var wire 1 # clk $end
$var wire 1 5 d $end
$var wire 1 P enable $end
$var wire 1 Q reset $end
$var reg 1 B q $end
$upscope $end
$scope module fsGarbage $end
$var wire 1 # clk $end
$var wire 1 6 d $end
$var wire 1 R enable $end
$var wire 1 S reset $end
$var reg 1 A q $end
$upscope $end
$scope module fsStart $end
$var wire 1 # clk $end
$var wire 1 7 d $end
$var wire 1 T enable $end
$var wire 1 U reset $end
$var reg 1 @ q $end
$upscope $end
$scope module fsUp1 $end
$var wire 1 # clk $end
$var wire 1 8 d $end
$var wire 1 V enable $end
$var wire 1 W reset $end
$var reg 1 ? q $end
$upscope $end
$scope module fsUp2 $end
$var wire 1 # clk $end
$var wire 1 9 d $end
$var wire 1 X enable $end
$var wire 1 Y reset $end
$var reg 1 > q $end
$upscope $end
$scope module fsUp3 $end
$var wire 1 # clk $end
$var wire 1 : d $end
$var wire 1 Z enable $end
$var wire 1 [ reset $end
$var reg 1 = q $end
$upscope $end
$scope module fsUp4 $end
$var wire 1 # clk $end
$var wire 1 ; d $end
$var wire 1 \ enable $end
$var wire 1 ] reset $end
$var reg 1 < q $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0]
1\
0[
1Z
0Y
1X
0W
1V
0U
1T
0S
1R
0Q
1P
0O
1N
0M
1L
0K
1J
0I
1H
b0xxxx G
xF
xE
xD
xC
xB
xA
x@
x?
x>
x=
x<
0;
0:
09
08
07
16
05
04
03
02
01
b100000 0
b0xxxx /
bz .
bx -
bz ,
bx +
x*
bx )
bx (
1'
0&
0%
bx $
0#
x"
b0xxxx !
$end
#1
b0 !
b0 /
b0 G
1*
0"
1A
0@
0?
0>
0=
0<
0E
0D
0C
0B
0F
1#
#2
0#
0'
#3
1#
#4
17
06
0#
b110100000000 $
b110100000000 )
1&
#5
b1000 !
b1000 /
b1000 G
0A
1@
1#
b110100000000 (
#6
07
12
0#
b110100000001 $
b110100000001 )
0&
#7
02
13
b111 !
b111 /
b111 G
1E
0@
1#
b110100000001 (
#8
0#
b110100000010 $
b110100000010 )
#9
b110 !
b110 /
b110 G
03
14
0E
1D
1#
b110100000010 (
#10
0#
b110100000011 $
b110100000011 )
#11
b101 !
b101 /
b101 G
15
04
1C
0D
1#
b110100000011 (
#12
0#
b110100000100 $
b110100000100 )
#13
b100 !
b100 /
b100 G
11
05
0C
1B
1#
b110100000100 (
#14
0#
b110100000101 $
b110100000101 )
#15
b0 !
b0 /
b0 G
0*
1"
1F
0B
1#
b110100000101 (
#16
0#
#17
1#
#18
0#
#19
1#
#20
0#
#21
1#
#22
01
b100000 0
16
0#
1'
#23
1*
0"
0F
1A
1#
#24
0#
0'
#25
1#
#26
17
06
0#
1%
b110111111111 $
b110111111111 )
1&
#27
b1000 !
b1000 /
b1000 G
1@
0A
1#
b110111111111 (
#28
07
18
0#
b110111111110 $
b110111111110 )
0&
#29
0*
1"
08
b1001 !
b1001 /
b1001 G
19
0@
1?
1#
b110111111110 (
#30
0#
b110111111101 $
b110111111101 )
#31
b1010 !
b1010 /
b1010 G
1:
09
1>
0?
1#
b110111111101 (
#32
0#
b110111111100 $
b110111111100 )
#33
b1011 !
b1011 /
b1011 G
0:
1;
0>
1=
1#
b110111111100 (
#34
0#
b110111111011 $
b110111111011 )
#35
b1100 !
b1100 /
b1100 G
11
0;
1<
0=
1#
b110111111011 (
#36
0#
b110111111010 $
b110111111010 )
#37
b0 !
b0 /
b0 G
0<
1F
1#
b110111111010 (
#38
0#
#39
1#
#40
0#
#41
1#
#42
0#
#43
1#
#44
0#
#45
1#
#46
0#
